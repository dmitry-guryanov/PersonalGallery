<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
	<title>SQLAlchemy 0.5 Documentation - module sqlalchemy.orm.session</title>
	
    
    <link rel="stylesheet" href="style.css"></link>
    <link rel="stylesheet" href="docs.css"></link>
    <link href="syntaxhighlight.css" rel="stylesheet" type="text/css"></link>
    <script src="scripts.js"></script>

    <link rel="stylesheet" href="docutil.css"></link>



</head>
<body>








<div id="topanchor"><a name="top">&nbsp;</a></div>


<h1>SQLAlchemy 0.5 Documentation</h1>

<div id="pagecontrol"><a href="index.html">Multiple Pages</a> | <a href="documentation.html">One Page</a></div>

<div class="versionheader">
  Version: <span class="versionnum">0.5.0rc4</span>
  Last Updated: 11/14/08 16:38:11
</div>












    <div class="topnav">

    
    <div class="navbanner">
        <a href="index.html" class="totoc">Table of Contents</a>
        
    <div class="prevnext">
            Up: <a href="docstrings.html">API Documentation</a>

               |   
            Previous: <a href="sqlalchemy_orm_query.html">module sqlalchemy.orm.query</a>

               |   
            Next: <a href="sqlalchemy_orm_shard.html">module sqlalchemy.orm.shard</a>
    </div>

        <h2>module sqlalchemy.orm.session</h2>
    </div>

	
	
    <ul>
        
        <li><a style="" href="sqlalchemy_orm_session.html#docstrings_sqlalchemy.orm.session_Session">class Session(object)</a></li>

        
        <li><a style="" href="sqlalchemy_orm_session.html#docstrings_sqlalchemy.orm.session_SessionExtension">class SessionExtension(object)</a></li>

    </ul>

	</div>



    

    
    
    <A name="docstrings_sqlalchemy.orm.session"></a>
    
    <div class="sectionL2">

    <h3>module sqlalchemy.orm.session</h3>
    
    
    <div class="darkcell"><p>Provides the Session class and related utilities.</p>
</div>
    


            
    

    
    
    <A name="docstrings_sqlalchemy.orm.session_Session"></a>
    
    <div class="sectionL3">

    <h3>class Session(object)</h3>
    
    
    <div class="darkcell"><p>Manages persistence operations for ORM-mapped objects.</p>
<p>The Session is the front end to SQLAlchemy's <strong>Unit of Work</strong>
implementation.  The concept behind Unit of Work is to track modifications
to a field of objects, and then be able to flush those changes to the
database in a single operation.</p>
<p>SQLAlchemy's unit of work includes these functions:</p>
<ul class="simple">
<li>The ability to track in-memory changes on scalar- and collection-based
object attributes, such that database persistence operations can be
assembled based on those changes.</li>
<li>The ability to organize individual SQL queries and population of newly
generated primary and foreign key-holding attributes during a persist
operation such that referential integrity is maintained at all times.</li>
<li>The ability to maintain insert ordering against the order in which new
instances were added to the session.</li>
<li>An Identity Map, which is a dictionary keying instances to their unique
primary key identity. This ensures that only one copy of a particular
entity is ever present within the session, even if repeated load
operations for the same entity occur. This allows many parts of an
application to get a handle to a particular object without any chance of
modifications going to two different places.</li>
</ul>
<p>When dealing with instances of mapped classes, an instance may be
<em>attached</em> to a particular Session, else it is <em>unattached</em> . An instance
also may or may not correspond to an actual row in the database. These
conditions break up into four distinct states:</p>
<ul class="simple">
<li><em>Transient</em> - an instance that's not in a session, and is not saved to
the database; i.e. it has no database identity. The only relationship
such an object has to the ORM is that its class has a <tt class="docutils literal"><span class="pre">mapper()</span></tt>
associated with it.</li>
<li><em>Pending</em> - when you <tt class="docutils literal"><span class="pre">add()</span></tt> a transient instance, it becomes
pending. It still wasn't actually flushed to the database yet, but it
will be when the next flush occurs.</li>
<li><em>Persistent</em> - An instance which is present in the session and has a
record in the database. You get persistent instances by either flushing
so that the pending instances become persistent, or by querying the
database for existing instances (or moving persistent instances from
other sessions into your local session).</li>
<li><em>Detached</em> - an instance which has a record in the database, but is not
in any session. Theres nothing wrong with this, and you can use objects
normally when they're detached, <strong>except</strong> they will not be able to
issue any SQL in order to load collections or attributes which are not
yet loaded, or were marked as &quot;expired&quot;.</li>
</ul>
<p>The session methods which control instance state include <tt class="docutils literal"><span class="pre">add()</span></tt>,
<tt class="docutils literal"><span class="pre">delete()</span></tt>, <tt class="docutils literal"><span class="pre">merge()</span></tt>, and <tt class="docutils literal"><span class="pre">expunge()</span></tt>.</p>
<p>The Session object is generally <strong>not</strong> threadsafe.  A session which is
set to <tt class="docutils literal"><span class="pre">autocommit</span></tt> and is only read from may be used by concurrent
threads if it's acceptable that some object instances may be loaded twice.</p>
<p>The typical pattern to managing Sessions in a multi-threaded environment
is either to use mutexes to limit concurrent access to one thread at a
time, or more commonly to establish a unique session for every thread,
using a threadlocal variable.  SQLAlchemy provides a thread-managed
Session adapter, provided by the <a href="sqlalchemy_orm.html#docstrings_sqlalchemy.orm_modfunc_scoped_session">scoped_session()</a>
function.</p>
</div>
    

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __init__(<i>self</i>, <i>bind=None</i>, <i>autoflush=True</i>, <i>expire_on_commit=True</i>, <i>_enable_transaction_accounting=True</i>, <i>autocommit=False</i>, <i>twophase=False</i>, <i>echo_uow=None</i>, <i>weak_identity_map=True</i>, <i>binds=None</i>, <i>extension=None</i>, <i>query_cls=<class 'sqlalchemy.orm.query.Query'></i>)</b>
    <div class="docstring">
    <p>Construct a new Session.</p>
<p>Arguments to <tt class="docutils literal"><span class="pre">Session</span></tt> are described using the
<a href="sqlalchemy_orm.html#docstrings_sqlalchemy.orm_modfunc_sessionmaker">sessionmaker()</a> function.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def add(<i>self</i>, <i>instance</i>)</b>
    <div class="docstring">
    <p>Add the given instance into this <tt class="docutils literal"><span class="pre">Session</span></tt>.</p>
<p>TODO: rephrase the below in user terms; possibly tie into future
function that downgrades persistent to transient. [ticket:1052]</p>
<p>The non-None state <cite>key</cite> on the instance's state determines whether
to <tt class="docutils literal"><span class="pre">save()</span></tt> or <tt class="docutils literal"><span class="pre">update()</span></tt> the instance.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def save_or_update(<i>self</i>, <i>instance</i>)</b>
    <div class="docstring">
    <p>Add the given instance into this <tt class="docutils literal"><span class="pre">Session</span></tt>.</p>
<p>Use session.add()</p>
<p>TODO: rephrase the below in user terms; possibly tie into future
function that downgrades persistent to transient. [ticket:1052]</p>
<p>The non-None state <cite>key</cite> on the instance's state determines whether
to <tt class="docutils literal"><span class="pre">save()</span></tt> or <tt class="docutils literal"><span class="pre">update()</span></tt> the instance.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def add_all(<i>self</i>, <i>instances</i>)</b>
    <div class="docstring">
    <p>Add the given collection of instances to this <tt class="docutils literal"><span class="pre">Session</span></tt>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def begin(<i>self</i>, <i>subtransactions=False</i>, <i>nested=False</i>)</b>
    <div class="docstring">
    <p>Begin a transaction on this Session.</p>
<p>If this Session is already within a transaction, either a plain
transaction or nested transaction, an error is raised, unless
<tt class="docutils literal"><span class="pre">subtransactions=True</span></tt> or <tt class="docutils literal"><span class="pre">nested=True</span></tt> is specified.</p>
<p>The <tt class="docutils literal"><span class="pre">subtransactions=True</span></tt> flag indicates that this <tt class="docutils literal"><span class="pre">begin()</span></tt> can
create a subtransaction if a transaction is already in progress.  A
subtransaction is a non-transactional, delimiting construct that
allows matching begin()/commit() pairs to be nested together, with
only the outermost begin/commit pair actually affecting transactional
state.  When a rollback is issued, the subtransaction will directly
roll back the innermost real transaction, however each subtransaction
still must be explicitly rolled back to maintain proper stacking of
subtransactions.</p>
<p>If no transaction is in progress, then a real transaction is begun.</p>
<p>The <tt class="docutils literal"><span class="pre">nested</span></tt> flag begins a SAVEPOINT transaction and is equivalent
to calling <tt class="docutils literal"><span class="pre">begin_nested()</span></tt>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def begin_nested(<i>self</i>)</b>
    <div class="docstring">
    <p>Begin a <cite>nested</cite> transaction on this Session.</p>
<p>The target database(s) must support SQL SAVEPOINTs or a
SQLAlchemy-supported vendor implementation of the idea.</p>
<p>The nested transaction is a real transation, unlike a &quot;subtransaction&quot;
which corresponds to multiple <tt class="docutils literal"><span class="pre">begin()</span></tt> calls.  The next
<tt class="docutils literal"><span class="pre">rollback()</span></tt> or <tt class="docutils literal"><span class="pre">commit()</span></tt> call will operate upon this nested
transaction.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def bind_mapper(<i>self</i>, <i>mapper</i>, <i>bind</i>)</b>
    <div class="docstring">
    <p>Bind operations for a mapper to a Connectable.</p>
<dl class="docutils">
<dt>mapper</dt>
<dd>A mapper instance or mapped class</dd>
<dt>bind</dt>
<dd>Any Connectable: a <tt class="docutils literal"><span class="pre">Engine</span></tt> or <tt class="docutils literal"><span class="pre">Connection</span></tt>.</dd>
</dl>
<p>All subsequent operations involving this mapper will use the given
<cite>bind</cite>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def bind_table(<i>self</i>, <i>table</i>, <i>bind</i>)</b>
    <div class="docstring">
    <p>Bind operations on a Table to a Connectable.</p>
<dl class="docutils">
<dt>table</dt>
<dd>A <tt class="docutils literal"><span class="pre">Table</span></tt> instance</dd>
<dt>bind</dt>
<dd>Any Connectable: a <tt class="docutils literal"><span class="pre">Engine</span></tt> or <tt class="docutils literal"><span class="pre">Connection</span></tt>.</dd>
</dl>
<p>All subsequent operations involving this <tt class="docutils literal"><span class="pre">Table</span></tt> will use the
given <cite>bind</cite>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def close(<i>self</i>)</b>
    <div class="docstring">
    <p>Close this Session.</p>
<p>This clears all items and ends any transaction in progress.</p>
<p>If this session were created with <tt class="docutils literal"><span class="pre">autocommit=False</span></tt>, a new
transaction is immediately begun.  Note that this new transaction does
not use any connection resources until they are first needed.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def close_all(<i>cls</i>)</b>
    <div class="docstring">
    <p>Close <em>all</em> sessions in memory.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def commit(<i>self</i>)</b>
    <div class="docstring">
    <p>Flush pending changes and commit the current transaction.</p>
<p>If no transaction is in progress, this method raises an
InvalidRequestError.</p>
<p>If a subtransaction is in effect (which occurs when begin() is called
multiple times), the subtransaction will be closed, and the next call
to <tt class="docutils literal"><span class="pre">commit()</span></tt> will operate on the enclosing transaction.</p>
<p>For a session configured with autocommit=False, a new transaction will
be begun immediately after the commit, but note that the newly begun
transaction does <em>not</em> use any connection resources until the first
SQL is actually emitted.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def connection(<i>self</i>, <i>mapper=None</i>, <i>clause=None</i>, <i>_state=None</i>)</b>
    <div class="docstring">
    <p>Return the active Connection.</p>
<p>Retrieves the <tt class="docutils literal"><span class="pre">Connection</span></tt> managing the current transaction.  Any
operations executed on the Connection will take place in the same
transactional context as <tt class="docutils literal"><span class="pre">Session</span></tt> operations.</p>
<p>For <tt class="docutils literal"><span class="pre">autocommit</span></tt> Sessions with no active manual transaction,
<tt class="docutils literal"><span class="pre">connection()</span></tt> is a passthrough to <tt class="docutils literal"><span class="pre">contextual_connect()</span></tt> on the
underlying engine.</p>
<p>Ambiguity in multi-bind or unbound Sessions can be resolved through
any of the optional keyword arguments.  See <tt class="docutils literal"><span class="pre">get_bind()</span></tt> for more
information.</p>
<dl class="docutils">
<dt>mapper</dt>
<dd>Optional, a <tt class="docutils literal"><span class="pre">mapper</span></tt> or mapped class</dd>
<dt>clause</dt>
<dd>Optional, any <tt class="docutils literal"><span class="pre">ClauseElement</span></tt></dd>
</dl>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def delete(<i>self</i>, <i>instance</i>)</b>
    <div class="docstring">
    <p>Mark an instance as deleted.</p>
<p>The database delete operation occurs upon <tt class="docutils literal"><span class="pre">flush()</span></tt>.</p>

    </div>
    </div>

                    
         <div class="darkcell">
         <A name=""></a>
         <b>deleted = property()</b>
         <div class="docstring">
         <p>The set of all instances marked as 'deleted' within this <tt class="docutils literal"><span class="pre">Session</span></tt></p>

         </div> 
         </div>

                    
         <div class="darkcell">
         <A name=""></a>
         <b>dirty = property()</b>
         <div class="docstring">
         <p>The set of all persistent instances considered dirty.</p>
<p>Instances are considered dirty when they were modified but not
deleted.</p>
<p>Note that this 'dirty' calculation is 'optimistic'; most
attribute-setting or collection modification operations will
mark an instance as 'dirty' and place it in this set, even if
there is no net change to the attribute's value.  At flush
time, the value of each attribute is compared to its
previously saved value, and if there's no net change, no SQL
operation will occur (this is a more expensive operation so
it's only done at flush time).</p>
<p>To check if an instance has actionable net changes to its
attributes, use the is_modified() method.</p>

         </div> 
         </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def execute(<i>self</i>, <i>clause</i>, <i>params=None</i>, <i>mapper=None</i>, <i>_state=None</i>)</b>
    <div class="docstring">
    <p>Execute a clause within the current transaction.</p>
<p>Returns a <tt class="docutils literal"><span class="pre">ResultProxy</span></tt> of execution results.  <cite>autocommit</cite> Sessions
will create a transaction on the fly.</p>
<p>Connection ambiguity in multi-bind or unbound Sessions will be
resolved by inspecting the clause for binds.  The 'mapper' and
'instance' keyword arguments may be used if this is insufficient, See
<tt class="docutils literal"><span class="pre">get_bind()</span></tt> for more information.</p>
<dl class="docutils">
<dt>clause</dt>
<dd>A ClauseElement (i.e. select(), text(), etc.) or
string SQL statement to be executed</dd>
<dt>params</dt>
<dd>Optional, a dictionary of bind parameters.</dd>
<dt>mapper</dt>
<dd>Optional, a <tt class="docutils literal"><span class="pre">mapper</span></tt> or mapped class</dd>
<dt>_state</dt>
<dd>Optional, an instance of a mapped class</dd>
</dl>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def expire(<i>self</i>, <i>instance</i>, <i>attribute_names=None</i>)</b>
    <div class="docstring">
    <p>Expire the attributes on an instance.</p>
<p>Marks the attributes of an instance as out of date.  When an expired
attribute is next accessed, query will be issued to the database and
the attributes will be refreshed with their current database value.
<tt class="docutils literal"><span class="pre">expire()</span></tt> is a lazy variant of <tt class="docutils literal"><span class="pre">refresh()</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">attribute_names</span></tt> argument is an iterable collection
of attribute names indicating a subset of attributes to be
expired.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def expire_all(<i>self</i>)</b>
    <div class="docstring">
    <p>Expires all persistent instances within this Session.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def expunge(<i>self</i>, <i>instance</i>)</b>
    <div class="docstring">
    <p>Remove the <cite>instance</cite> from this <tt class="docutils literal"><span class="pre">Session</span></tt>.</p>
<p>This will free all internal references to the instance.  Cascading
will be applied according to the <em>expunge</em> cascade rule.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def expunge_all(<i>self</i>)</b>
    <div class="docstring">
    <p>Remove all object instances from this <tt class="docutils literal"><span class="pre">Session</span></tt>.</p>
<p>This is equivalent to calling <tt class="docutils literal"><span class="pre">expunge(obj)</span></tt> on all objects in this
<tt class="docutils literal"><span class="pre">Session</span></tt>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def clear(<i>self</i>)</b>
    <div class="docstring">
    <p>Remove all object instances from this <tt class="docutils literal"><span class="pre">Session</span></tt>.</p>
<p>This is equivalent to calling <tt class="docutils literal"><span class="pre">expunge(obj)</span></tt> on all objects in this
<tt class="docutils literal"><span class="pre">Session</span></tt>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def flush(<i>self</i>, <i>objects=None</i>)</b>
    <div class="docstring">
    <p>Flush all the object changes to the database.</p>
<p>Writes out all pending object creations, deletions and modifications
to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
automatically ordered by the Session's unit of work dependency
solver..</p>
<p>Database operations will be issued in the current transactional
context and do not affect the state of the transaction.  You may
flush() as often as you like within a transaction to move changes from
Python to the database's transaction buffer.</p>
<p>For <tt class="docutils literal"><span class="pre">autocommit</span></tt> Sessions with no active manual transaction, flush()
will create a transaction on the fly that surrounds the entire set of
operations int the flush.</p>
<dl class="docutils">
<dt>objects</dt>
<dd>Optional; a list or tuple collection.  Restricts the flush operation
to only these objects, rather than all pending changes.</dd>
</dl>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def get_bind(<i>self</i>, <i>mapper</i>, <i>clause=None</i>, <i>_state=None</i>)</b>
    <div class="docstring">
    <p>Return an engine corresponding to the given arguments.</p>
<p>All arguments are optional.</p>
<dl class="docutils">
<dt>mapper</dt>
<dd>Optional, a <tt class="docutils literal"><span class="pre">Mapper</span></tt> or mapped class</dd>
<dt>clause</dt>
<dd>Optional, A ClauseElement (i.e. select(), text(), etc.)</dd>
<dt>_state</dt>
<dd>Optional, SA internal representation of a mapped instance</dd>
</dl>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def identity_key(<i>cls</i>, <i>*args</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
         <div class="darkcell">
         <A name=""></a>
         <b>is_active = property()</b>
         <div class="docstring">
         <p>True if this Session has an active transaction.</p>

         </div> 
         </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def is_modified(<i>self</i>, <i>instance</i>, <i>include_collections=True</i>, <i>passive=False</i>)</b>
    <div class="docstring">
    <p>Return True if instance has modified attributes.</p>
<p>This method retrieves a history instance for each instrumented
attribute on the instance and performs a comparison of the current
value to its previously committed value.  Note that instances present
in the 'dirty' collection may result in a value of <tt class="docutils literal"><span class="pre">False</span></tt> when
tested with this method.</p>
<p><cite>include_collections</cite> indicates if multivalued collections should be
included in the operation.  Setting this to False is a way to detect
only local-column based properties (i.e. scalar columns or many-to-one
foreign keys) that would result in an UPDATE for this instance upon
flush.</p>
<p>The <cite>passive</cite> flag indicates if unloaded attributes and collections
should not be loaded in the course of performing this test.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def merge(<i>self</i>, <i>instance</i>, <i>dont_load=False</i>, <i>_recursive=None</i>)</b>
    <div class="docstring">
    <p>Copy the state an instance onto the persistent instance with the same identifier.</p>
<p>If there is no persistent instance currently associated with the
session, it will be loaded.  Return the persistent instance. If the
given instance is unsaved, save a copy of and return it as a newly
persistent instance. The given instance does not become associated
with the session.</p>
<p>This operation cascades to associated instances if the association is
mapped with <tt class="docutils literal"><span class="pre">cascade=&quot;merge&quot;</span></tt>.</p>

    </div>
    </div>

                    
         <div class="darkcell">
         <A name=""></a>
         <b>new = property()</b>
         <div class="docstring">
         <p>The set of all instances marked as 'new' within this <tt class="docutils literal"><span class="pre">Session</span></tt>.</p>

         </div> 
         </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def object_session(<i>cls</i>, <i>instance</i>)</b>
    <div class="docstring">
    <p>Return the <tt class="docutils literal"><span class="pre">Session</span></tt> to which an object belongs.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def prepare(<i>self</i>)</b>
    <div class="docstring">
    <p>Prepare the current transaction in progress for two phase commit.</p>
<p>If no transaction is in progress, this method raises an
InvalidRequestError.</p>
<p>Only root transactions of two phase sessions can be prepared. If the
current transaction is not such, an InvalidRequestError is raised.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def prune(<i>self</i>)</b>
    <div class="docstring">
    <p>Remove unreferenced instances cached in the identity map.</p>
<p>Note that this method is only meaningful if &quot;weak_identity_map&quot; is set
to False.  The default weak identity map is self-pruning.</p>
<p>Removes any object in this Session's identity map that is not
referenced in user code, modified, new or scheduled for deletion.
Returns the number of objects pruned.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def query(<i>self</i>, <i>*entities</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    <p>Return a new <tt class="docutils literal"><span class="pre">Query</span></tt> object corresponding to this <tt class="docutils literal"><span class="pre">Session</span></tt>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def refresh(<i>self</i>, <i>instance</i>, <i>attribute_names=None</i>)</b>
    <div class="docstring">
    <p>Refresh the attributes on the given instance.</p>
<p>A query will be issued to the database and all attributes will be
refreshed with their current database value.</p>
<p>Lazy-loaded relational attributes will remain lazily loaded, so that
the instance-wide refresh operation will be followed immediately by
the lazy load of that attribute.</p>
<p>Eagerly-loaded relational attributes will eagerly load within the
single refresh operation.</p>
<p>The <tt class="docutils literal"><span class="pre">attribute_names</span></tt> argument is an iterable collection of
attribute names indicating a subset of attributes to be refreshed.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def rollback(<i>self</i>)</b>
    <div class="docstring">
    <p>Rollback the current transaction in progress.</p>
<p>If no transaction is in progress, this method is a pass-through.</p>
<p>This method rolls back the current transaction or nested transaction
regardless of subtransactions being in effect.  All subtrasactions up
to the first real transaction are closed.  Subtransactions occur when
begin() is called mulitple times.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def save(<i>self</i>, <i>instance</i>)</b>
    <div class="docstring">
    <p>Add a transient (unsaved) instance to this <tt class="docutils literal"><span class="pre">Session</span></tt>.</p>
<p>Use session.add()</p>
<p>This operation cascades the <cite>save_or_update</cite> method to associated
instances if the relation is mapped with <tt class="docutils literal"><span class="pre">cascade=&quot;save-update&quot;</span></tt>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def scalar(<i>self</i>, <i>clause</i>, <i>params=None</i>, <i>mapper=None</i>, <i>_state=None</i>)</b>
    <div class="docstring">
    <p>Like execute() but return a scalar result.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def update(<i>self</i>, <i>instance</i>)</b>
    <div class="docstring">
    <p>Bring a detached (saved) instance into this <tt class="docutils literal"><span class="pre">Session</span></tt>.</p>
<p>Use session.add()</p>
<p>If there is a persistent instance with the same instance key, but
different identity already associated with this <tt class="docutils literal"><span class="pre">Session</span></tt>, an
InvalidRequestError exception is thrown.</p>
<p>This operation cascades the <cite>save_or_update</cite> method to associated
instances if the relation is mapped with <tt class="docutils literal"><span class="pre">cascade=&quot;save-update&quot;</span></tt>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __contains__(<i>self</i>, <i>instance</i>)</b>
    <div class="docstring">
    <p>Return True if the instance is associated with this session.</p>
<p>The instance may be pending or persistent within the Session for a
result of True.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __iter__(<i>self</i>)</b>
    <div class="docstring">
    <p>Iterate over all pending or persistent instances within this Session.</p>

    </div>
    </div>


    

            <a href="#top" class="totoc">back to section top</a>
    </div>



            
    

    
    
    <A name="docstrings_sqlalchemy.orm.session_SessionExtension"></a>
    
    <div class="sectionL3">

    <h3>class SessionExtension(object)</h3>
    
    
    <div class="darkcell"><p>An extension hook object for Sessions.  Subclasses may be installed into a Session
(or sessionmaker) using the <tt class="docutils literal"><span class="pre">extension</span></tt> keyword argument.</p>
</div>
    

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def after_attach(<i>self</i>, <i>session</i>, <i>instance</i>)</b>
    <div class="docstring">
    <p>Execute after an instance is attached to a session.</p>
<p>This is called after an add, delete or merge.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def after_begin(<i>self</i>, <i>session</i>, <i>transaction</i>, <i>connection</i>)</b>
    <div class="docstring">
    <p>Execute after a transaction is begun on a connection</p>
<p><cite>transaction</cite> is the SessionTransaction. This method is called after an
engine level transaction is begun on a connection.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def after_bulk_delete(<i>self</i>, <i>session</i>, <i>query</i>, <i>query_context</i>, <i>result</i>)</b>
    <div class="docstring">
    <p>Execute after a bulk delete operation to the session.</p>
<p>This is called after a session.query(...).delete()</p>
<p><cite>query</cite> is the query object that this delete operation was called on.
<cite>query_context</cite> was the query context object.
<cite>result</cite> is the result object returned from the bulk operation.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def after_bulk_update(<i>self</i>, <i>session</i>, <i>query</i>, <i>query_context</i>, <i>result</i>)</b>
    <div class="docstring">
    <p>Execute after a bulk update operation to the session.</p>
<p>This is called after a session.query(...).update()</p>
<p><cite>query</cite> is the query object that this update operation was called on.
<cite>query_context</cite> was the query context object.
<cite>result</cite> is the result object returned from the bulk operation.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def after_commit(<i>self</i>, <i>session</i>)</b>
    <div class="docstring">
    <p>Execute after a commit has occured.</p>
<p>Note that this may not be per-flush if a longer running transaction is ongoing.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def after_flush(<i>self</i>, <i>session</i>, <i>flush_context</i>)</b>
    <div class="docstring">
    <p>Execute after flush has completed, but before commit has been called.</p>
<p>Note that the session's state is still in pre-flush, i.e. 'new', 'dirty',
and 'deleted' lists still show pre-flush state as well as the history
settings on instance attributes.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def after_flush_postexec(<i>self</i>, <i>session</i>, <i>flush_context</i>)</b>
    <div class="docstring">
    <p>Execute after flush has completed, and after the post-exec state occurs.</p>
<p>This will be when the 'new', 'dirty', and 'deleted' lists are in their final
state.  An actual commit() may or may not have occured, depending on whether or not
the flush started its own transaction or participated in a larger transaction.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def after_rollback(<i>self</i>, <i>session</i>)</b>
    <div class="docstring">
    <p>Execute after a rollback has occured.</p>
<p>Note that this may not be per-flush if a longer running transaction is ongoing.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def before_commit(<i>self</i>, <i>session</i>)</b>
    <div class="docstring">
    <p>Execute right before commit is called.</p>
<p>Note that this may not be per-flush if a longer running transaction is ongoing.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def before_flush(<i>self</i>, <i>session</i>, <i>flush_context</i>, <i>instances</i>)</b>
    <div class="docstring">
    <p>Execute before flush process has started.</p>
<p><cite>instances</cite> is an optional list of objects which were passed to the <tt class="docutils literal"><span class="pre">flush()</span></tt>
method.</p>

    </div>
    </div>


    

            <a href="#top" class="totoc">back to section top</a>
    </div>



    

    </div>





    <div class="bottomnav">
        
    <div class="prevnext">
            Up: <a href="docstrings.html">API Documentation</a>

               |   
            Previous: <a href="sqlalchemy_orm_query.html">module sqlalchemy.orm.query</a>

               |   
            Next: <a href="sqlalchemy_orm_shard.html">module sqlalchemy.orm.shard</a>
    </div>

    </div>








</body>
</html>






