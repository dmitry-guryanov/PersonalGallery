<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
	<title>SQLAlchemy 0.5 Documentation - module sqlalchemy.ext.declarative</title>
	
    
    <link rel="stylesheet" href="style.css"></link>
    <link rel="stylesheet" href="docs.css"></link>
    <link href="syntaxhighlight.css" rel="stylesheet" type="text/css"></link>
    <script src="scripts.js"></script>

    <link rel="stylesheet" href="docutil.css"></link>



</head>
<body>








<div id="topanchor"><a name="top">&nbsp;</a></div>


<h1>SQLAlchemy 0.5 Documentation</h1>

<div id="pagecontrol"><a href="index.html">Multiple Pages</a> | <a href="documentation.html">One Page</a></div>

<div class="versionheader">
  Version: <span class="versionnum">0.5.0rc4</span>
  Last Updated: 11/14/08 16:38:11
</div>












    <div class="topnav">

    
    <div class="navbanner">
        <a href="index.html" class="totoc">Table of Contents</a>
        
    <div class="prevnext">
            Up: <a href="docstrings.html">API Documentation</a>

               |   
            Previous: <a href="sqlalchemy_orm_shard.html">module sqlalchemy.orm.shard</a>

               |   
            Next: <a href="sqlalchemy_ext_associationproxy.html">module sqlalchemy.ext.associationproxy</a>
    </div>

        <h2>module sqlalchemy.ext.declarative</h2>
    </div>

	
	
    <ul>
        
        <li><a style="" href="sqlalchemy_ext_declarative.html#docstrings_sqlalchemy.ext.declarative_modfunc">Module Functions</a></li>

	        <li>
                
    <ul>
        
        <li><a style="" href="sqlalchemy_ext_declarative.html#docstrings_sqlalchemy.ext.declarative_modfunc_comparable_using">comparable_using()</a></li>

        
        <li><a style="" href="sqlalchemy_ext_declarative.html#docstrings_sqlalchemy.ext.declarative_modfunc_declarative_base">declarative_base()</a></li>

        
        <li><a style="" href="sqlalchemy_ext_declarative.html#docstrings_sqlalchemy.ext.declarative_modfunc_instrument_declarative">instrument_declarative()</a></li>

        
        <li><a style="" href="sqlalchemy_ext_declarative.html#docstrings_sqlalchemy.ext.declarative_modfunc_synonym_for">synonym_for()</a></li>

    </ul>

	        </li>
    </ul>

	</div>



    

    
    
    <A name="docstrings_sqlalchemy.ext.declarative"></a>
    
    <div class="sectionL2">

    <h3>module sqlalchemy.ext.declarative</h3>
    
    
    <div class="darkcell"><p>A simple declarative layer for SQLAlchemy ORM.</p>
<p>SQLAlchemy object-relational configuration involves the usage of Table,
mapper(), and class objects to define the three areas of configuration.
declarative moves these three types of configuration underneath the individual
mapped class.  Regular SQLAlchemy schema and ORM constructs are used in most
cases:</p>
<pre class="literal-block">
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class SomeClass(Base):
    __tablename__ = 'some_table'
    id = Column('id', Integer, primary_key=True)
    name =  Column('name', String(50))
</pre>
<p>Above, the <tt class="docutils literal"><span class="pre">declarative_base</span></tt> callable produces a new base class from which
all mapped classes inherit from.  When the class definition is completed, a
new <tt class="docutils literal"><span class="pre">Table</span></tt> and <tt class="docutils literal"><span class="pre">mapper()</span></tt> have been generated, accessible via the
<tt class="docutils literal"><span class="pre">__table__</span></tt> and <tt class="docutils literal"><span class="pre">__mapper__</span></tt> attributes on the <tt class="docutils literal"><span class="pre">SomeClass</span></tt> class.</p>
<p>You may omit the names from the Column definitions.  Declarative will fill
them in for you:</p>
<pre class="literal-block">
class SomeClass(Base):
    __tablename__ = 'some_table'
    id = Column(Integer, primary_key=True)
    name = Column(String(50))
</pre>
<p>Attributes may be added to the class after its construction, and they will be
added to the underlying <tt class="docutils literal"><span class="pre">Table</span></tt> and <tt class="docutils literal"><span class="pre">mapper()</span></tt> definitions as
appropriate:</p>
<pre class="literal-block">
SomeClass.data = Column('data', Unicode)
SomeClass.related = relation(RelatedInfo)
</pre>
<p>Classes which are mapped explicitly using <tt class="docutils literal"><span class="pre">mapper()</span></tt> can interact freely
with declarative classes.</p>
<p>The <tt class="docutils literal"><span class="pre">declarative_base</span></tt> base class contains a <tt class="docutils literal"><span class="pre">MetaData</span></tt> object where newly
defined <tt class="docutils literal"><span class="pre">Table</span></tt> objects are collected.  This is accessed via the
<tt class="docutils literal"><span class="pre">metadata</span></tt> class level accessor, so to create tables we can say:</p>
<pre class="literal-block">
engine = create_engine('sqlite://')
Base.metadata.create_all(engine)
</pre>
<p>The <tt class="docutils literal"><span class="pre">Engine</span></tt> created above may also be directly associated with the
declarative base class using the <tt class="docutils literal"><span class="pre">engine</span></tt> keyword argument, where it will be
associated with the underlying <tt class="docutils literal"><span class="pre">MetaData</span></tt> object and allow SQL operations
involving that metadata and its tables to make use of that engine
automatically:</p>
<pre class="literal-block">
Base = declarative_base(engine=create_engine('sqlite://'))
</pre>
<p>Or, as <tt class="docutils literal"><span class="pre">MetaData</span></tt> allows, at any time using the <tt class="docutils literal"><span class="pre">bind</span></tt> attribute:</p>
<pre class="literal-block">
Base.metadata.bind = create_engine('sqlite://')
</pre>
<p>The <tt class="docutils literal"><span class="pre">declarative_base</span></tt> can also receive a pre-created <tt class="docutils literal"><span class="pre">MetaData</span></tt> object,
which allows a declarative setup to be associated with an already existing
traditional collection of <tt class="docutils literal"><span class="pre">Table</span></tt> objects:</p>
<pre class="literal-block">
mymetadata = MetaData()
Base = declarative_base(metadata=mymetadata)
</pre>
<p>Relations to other classes are done in the usual way, with the added feature
that the class specified to <tt class="docutils literal"><span class="pre">relation()</span></tt> may be a string name.  The &quot;class
registry&quot; associated with <tt class="docutils literal"><span class="pre">Base</span></tt> is used at mapper compilation time to
resolve the name into the actual class object, which is expected to have been
defined once the mapper configuration is used:</p>
<pre class="literal-block">
class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    name = Column(String(50))
    addresses = relation(&quot;Address&quot;, backref=&quot;user&quot;)

class Address(Base):
    __tablename__ = 'addresses'

    id = Column(Integer, primary_key=True)
    email = Column(String(50))
    user_id = Column(Integer, ForeignKey('users.id'))
</pre>
<p>Column constructs, since they are just that, are immediately usable, as below
where we define a primary join condition on the <tt class="docutils literal"><span class="pre">Address</span></tt> class using them:</p>
<pre class="literal-block">
class Address(Base)
    __tablename__ = 'addresses'

    id = Column(Integer, primary_key=True)
    email = Column(String(50))
    user_id = Column(Integer, ForeignKey('users.id'))
    user = relation(User, primaryjoin=user_id == User.id)
</pre>
<p>In addition to the main argument for <tt class="docutils literal"><span class="pre">relation</span></tt>, other arguments
which depend upon the columns present on an as-yet undefined class
may also be specified as strings.  These strings are evaluated as
Python expressions.  The full namespace available within this
evaluation includes all classes mapped for this declarative base,
as well as the contents of the <tt class="docutils literal"><span class="pre">sqlalchemy</span></tt> package, including
expression functions like <tt class="docutils literal"><span class="pre">desc</span></tt> and <tt class="docutils literal"><span class="pre">func</span></tt>:</p>
<pre class="literal-block">
class User(Base):
    # ....
    addresses = relation(&quot;Address&quot;, order_by=&quot;desc(Address.email)&quot;,
        primaryjoin=&quot;Address.user_id==User.id&quot;)
</pre>
<p>As an alternative to string-based attributes, attributes may also be
defined after all classes have been created.  Just add them to the target
class after the fact:</p>
<pre class="literal-block">
User.addresses = relation(Address, primaryjoin=Address.user_id == User.id)
</pre>
<p>Synonyms are one area where <tt class="docutils literal"><span class="pre">declarative</span></tt> needs to slightly change the usual
SQLAlchemy configurational syntax.  To define a getter/setter which proxies to
an underlying attribute, use <tt class="docutils literal"><span class="pre">synonym</span></tt> with the <tt class="docutils literal"><span class="pre">descriptor</span></tt> argument:</p>
<pre class="literal-block">
class MyClass(Base):
    __tablename__ = 'sometable'

    _attr = Column('attr', String)

    def _get_attr(self):
        return self._some_attr
    def _set_attr(self, attr)
        self._some_attr = attr
    attr = synonym('_attr', descriptor=property(_get_attr, _set_attr))
</pre>
<p>The above synonym is then usable as an instance attribute as well as a
class-level expression construct:</p>
<pre class="literal-block">
x = MyClass()
x.attr = &quot;some value&quot;
session.query(MyClass).filter(MyClass.attr == 'some other value').all()
</pre>
<p>The <cite>synonym_for</cite> decorator can accomplish the same task:</p>
<pre class="literal-block">
class MyClass(Base):
    __tablename__ = 'sometable'

    _attr = Column('attr', String)

    &#64;synonym_for('_attr')
    &#64;property
    def attr(self):
        return self._some_attr
</pre>
<p>Similarly, <cite>comparable_using</cite> is a front end for the <cite>comparable_property</cite> ORM function:</p>
<pre class="literal-block">
class MyClass(Base):
    __tablename__ = 'sometable'

    name = Column('name', String)

    &#64;comparable_using(MyUpperCaseComparator)
    &#64;property
    def uc_name(self):
        return self.name.upper()
</pre>
<p>As an alternative to <tt class="docutils literal"><span class="pre">__tablename__</span></tt>, a direct <tt class="docutils literal"><span class="pre">Table</span></tt> construct may be
used.  The <tt class="docutils literal"><span class="pre">Column</span></tt> objects, which in this case require their names, will be
added to the mapping just like a regular mapping to a table:</p>
<pre class="literal-block">
class MyClass(Base):
    __table__ = Table('my_table', Base.metadata,
        Column('id', Integer, primary_key=True),
        Column('name', String(50))
    )
</pre>
<p>Other table-based attributes include <tt class="docutils literal"><span class="pre">__table_args__</span></tt>, which is
either a dictionary as in:</p>
<pre class="literal-block">
class MyClass(Base)
    __tablename__ = 'sometable'
    __table_args__ = {'mysql_engine':'InnoDB'}
</pre>
<p>or a dictionary-containing tuple in the form
<tt class="docutils literal"><span class="pre">(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...,</span> <span class="pre">{kwarg1:value,</span> <span class="pre">...})</span></tt>, as in:</p>
<pre class="literal-block">
class MyClass(Base)
    __tablename__ = 'sometable'
    __table_args__ = (ForeignKeyConstraint(['id'], ['remote_table.id']), {'autoload':True})
</pre>
<p>Mapper arguments are specified using the <tt class="docutils literal"><span class="pre">__mapper_args__</span></tt> class variable.
Note that the column objects declared on the class are immediately usable, as
in this joined-table inheritance example:</p>
<pre class="literal-block">
class Person(Base):
    __tablename__ = 'people'
    id = Column(Integer, primary_key=True)
    discriminator = Column(String(50))
    __mapper_args__ = {'polymorphic_on': discriminator}

class Engineer(Person):
    __tablename__ = 'engineers'
    __mapper_args__ = {'polymorphic_identity': 'engineer'}
    id = Column(Integer, ForeignKey('people.id'), primary_key=True)
    primary_language = Column(String(50))
</pre>
<p>For single-table inheritance, the <tt class="docutils literal"><span class="pre">__tablename__</span></tt> and <tt class="docutils literal"><span class="pre">__table__</span></tt> class
variables are optional on a class when the class inherits from another mapped
class.</p>
<p>As a convenience feature, the <tt class="docutils literal"><span class="pre">declarative_base()</span></tt> sets a default
constructor on classes which takes keyword arguments, and assigns them to the
named attributes:</p>
<pre class="literal-block">
e = Engineer(primary_language='python')
</pre>
<p>Note that <tt class="docutils literal"><span class="pre">declarative</span></tt> has no integration built in with sessions, and is
only intended as an optional syntax for the regular usage of mappers and Table
objects.  A typical application setup using <tt class="docutils literal"><span class="pre">scoped_session</span></tt> might look
like:</p>
<pre class="literal-block">
engine = create_engine('postgres://scott:tiger&#64;localhost/test')
Session = scoped_session(sessionmaker(autocommit=False,
                                      autoflush=False,
                                      bind=engine))
Base = declarative_base()
</pre>
<p>Mapped instances then make usage of <tt class="docutils literal"><span class="pre">Session</span></tt> in the usual way.</p>
</div>
    

        
    
    <A name="docstrings_sqlalchemy.ext.declarative_modfunc"></a>
    
    <div class="sectionL3">

    <h3>Module Functions</h3>
    
    
                
    <div class="darkcell">
    
    <A name="docstrings_sqlalchemy.ext.declarative_modfunc_comparable_using"></a>
    <b>def comparable_using(<i>comparator_factory</i>)</b>
    <div class="docstring">
    <p>Decorator, allow a Python &#64;property to be used in query criteria.</p>
<p>A decorator front end to <a href="sqlalchemy_orm.html#docstrings_sqlalchemy.orm_modfunc_comparable_property">comparable_property()</a>, passes
through the comparator_factory and the function being decorated:</p>
<pre class="literal-block">
&#64;comparable_using(MyComparatorType)
&#64;property
def prop(self):
    return 'special sauce'
</pre>
<p>The regular <tt class="docutils literal"><span class="pre">comparable_property()</span></tt> is also usable directly in a
declarative setting and may be convenient for read/write properties:</p>
<pre class="literal-block">
prop = comparable_property(MyComparatorType)
</pre>

    </div>
    </div>

                
    <div class="darkcell">
    
    <A name="docstrings_sqlalchemy.ext.declarative_modfunc_declarative_base"></a>
    <b>def declarative_base(<i>bind=None</i>, <i>metadata=None</i>, <i>mapper=None</i>, <i>cls=<type 'object'></i>, <i>name='Base'</i>, <i>constructor=<function __init__ at 0xcc73b0></i>, <i>metaclass=<class 'sqlalchemy.ext.declarative.DeclarativeMeta'></i>, <i>engine=None</i>)</b>
    <div class="docstring">
    <p>Construct a base class for declarative class definitions.</p>
<p>The new base class will be given a metaclass that invokes
<cite>instrument_declarative()</cite> upon each subclass definition, and routes
later Column- and Mapper-related attribute assignments made on the class
into Table and Mapper assignments.  See the <cite>declarative</cite> module
documentation for examples.</p>
<dl class="docutils">
<dt>bind</dt>
<dd>An optional <cite>Connectable</cite>, will be assigned to the <cite>metadata.bind</cite>.
The <cite>engine</cite> keyword argument is a deprecated synonym for <cite>bind</cite>.</dd>
<dt>metadata</dt>
<dd>An optional <cite>MetaData</cite> instance.  All Tables implicitly declared by
subclasses of the base will share this MetaData.  A MetaData instance
will be create if none is provided.  The MetaData instance will be
available via the <cite>metadata</cite> attribute of the generated declarative
base class.</dd>
<dt>mapper</dt>
<dd>An optional callable, defaults to <cite>sqlalchemy.orm.mapper</cite>.  Will be
used to map subclasses to their Tables.</dd>
<dt>cls</dt>
<dd>Defaults to <cite>object</cite>.  A type to use as the base for the generated
declarative base class.  May be a type or tuple of types.</dd>
<dt>name</dt>
<dd>Defaults to 'Base', Python's internal display name for the generated
class.  Customizing this is not required, but can improve clarity in
tracebacks and debugging.</dd>
<dt>constructor</dt>
<dd>Defaults to declarative._declarative_constructor, an __init__
implementation that assigns **kwargs for declared fields and relations
to an instance.  If <cite>None</cite> is supplied, no __init__ will be installed
and construction will fall back to cls.__init__ with normal Python
semantics.</dd>
<dt>metaclass</dt>
<dd>Defaults to <cite>DeclarativeMeta</cite>.  A metaclass or __metaclass__
compatible callable to use as the meta type of the generated
declarative base class.</dd>
</dl>

    </div>
    </div>

                
    <div class="darkcell">
    
    <A name="docstrings_sqlalchemy.ext.declarative_modfunc_instrument_declarative"></a>
    <b>def instrument_declarative(<i>cls</i>, <i>registry</i>, <i>metadata</i>)</b>
    <div class="docstring">
    <p>Given a class, configure the class declaratively,
using the given registry (any dictionary) and MetaData object.
This operation does not assume any kind of class hierarchy.</p>

    </div>
    </div>

                
    <div class="darkcell">
    
    <A name="docstrings_sqlalchemy.ext.declarative_modfunc_synonym_for"></a>
    <b>def synonym_for(<i>name</i>, <i>map_column=False</i>)</b>
    <div class="docstring">
    <p>Decorator, make a Python &#64;property a query synonym for a column.</p>
<p>A decorator version of <a href="sqlalchemy_orm.html#docstrings_sqlalchemy.orm_modfunc_synonym">synonym()</a>.  The function being
decorated is the 'descriptor', otherwise passes its arguments through
to synonym():</p>
<pre class="literal-block">
&#64;synonym_for('col')
&#64;property
def prop(self):
    return 'special sauce'
</pre>
<p>The regular <tt class="docutils literal"><span class="pre">synonym()</span></tt> is also usable directly in a declarative setting
and may be convenient for read/write properties:</p>
<pre class="literal-block">
prop = synonym('col', descriptor=property(_read_prop, _write_prop))
</pre>

    </div>
    </div>

        

    </div>




    

    </div>





    <div class="bottomnav">
        
    <div class="prevnext">
            Up: <a href="docstrings.html">API Documentation</a>

               |   
            Previous: <a href="sqlalchemy_orm_shard.html">module sqlalchemy.orm.shard</a>

               |   
            Next: <a href="sqlalchemy_ext_associationproxy.html">module sqlalchemy.ext.associationproxy</a>
    </div>

    </div>








</body>
</html>






