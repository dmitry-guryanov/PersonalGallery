<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
	<title>SQLAlchemy 0.5 Documentation - module sqlalchemy.orm.query</title>
	
    
    <link rel="stylesheet" href="style.css"></link>
    <link rel="stylesheet" href="docs.css"></link>
    <link href="syntaxhighlight.css" rel="stylesheet" type="text/css"></link>
    <script src="scripts.js"></script>

    <link rel="stylesheet" href="docutil.css"></link>



</head>
<body>








<div id="topanchor"><a name="top">&nbsp;</a></div>


<h1>SQLAlchemy 0.5 Documentation</h1>

<div id="pagecontrol"><a href="index.html">Multiple Pages</a> | <a href="documentation.html">One Page</a></div>

<div class="versionheader">
  Version: <span class="versionnum">0.5.0rc4</span>
  Last Updated: 11/14/08 16:38:11
</div>












    <div class="topnav">

    
    <div class="navbanner">
        <a href="index.html" class="totoc">Table of Contents</a>
        
    <div class="prevnext">
            Up: <a href="docstrings.html">API Documentation</a>

               |   
            Previous: <a href="sqlalchemy_orm_properties.html">module sqlalchemy.orm.properties</a>

               |   
            Next: <a href="sqlalchemy_orm_session.html">module sqlalchemy.orm.session</a>
    </div>

        <h2>module sqlalchemy.orm.query</h2>
    </div>

	
	
    <ul>
        
        <li><a style="" href="sqlalchemy_orm_query.html#docstrings_sqlalchemy.orm.query_Query">class Query(object)</a></li>

    </ul>

	</div>



    

    
    
    <A name="docstrings_sqlalchemy.orm.query"></a>
    
    <div class="sectionL2">

    <h3>module sqlalchemy.orm.query</h3>
    
    
    <div class="darkcell"><p>The Query class and support.</p>
<p>Defines the <a href="sqlalchemy_orm_query.html#docstrings_sqlalchemy.orm.query_Query">Query</a> class, the central construct used by
the ORM to construct database queries.</p>
<p>The <tt class="docutils literal"><span class="pre">Query</span></tt> class should not be confused with the
<a href="sqlalchemy_sql_expression.html#docstrings_sqlalchemy.sql.expression_Select">Select</a> class, which defines database SELECT
operations at the SQL (non-ORM) level.  <tt class="docutils literal"><span class="pre">Query</span></tt> differs from <tt class="docutils literal"><span class="pre">Select</span></tt> in
that it returns ORM-mapped objects and interacts with an ORM session, whereas
the <tt class="docutils literal"><span class="pre">Select</span></tt> construct interacts directly with the database to return
iterable result sets.</p>
</div>
    


            
    

    
    
    <A name="docstrings_sqlalchemy.orm.query_Query"></a>
    
    <div class="sectionL3">

    <h3>class Query(object)</h3>
    
    
    <div class="darkcell"><p>Encapsulates the object-fetching operations provided by Mappers.</p>
</div>
    

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __init__(<i>self</i>, <i>entities</i>, <i>session=None</i>)</b>
    <div class="docstring">
    <p>Construct a new <tt class="docutils literal"><span class="pre">Query</span></tt>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def add_column(<i>self</i>, <i>column</i>)</b>
    <div class="docstring">
    <p>Add a SQL ColumnElement to the list of result columns to be returned.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def add_entity(<i>self</i>, <i>entity</i>, <i>alias=None</i>)</b>
    <div class="docstring">
    <p>add a mapped entity to the list of result columns to be returned.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def all(<i>self</i>)</b>
    <div class="docstring">
    <p>Return the results represented by this <tt class="docutils literal"><span class="pre">Query</span></tt> as a list.</p>
<p>This results in an execution of the underlying query.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def autoflush(<i>self</i>, <i>setting</i>)</b>
    <div class="docstring">
    <p>Return a Query with a specific 'autoflush' setting.</p>
<p>Note that a Session with autoflush=False will
not autoflush, even if this flag is set to True at the
Query level.  Therefore this flag is usually used only
to disable autoflush for a specific Query.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def correlate(<i>self</i>, <i>*args</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def count(<i>self</i>)</b>
    <div class="docstring">
    <p>Apply this query's criterion to a SELECT COUNT statement.</p>
<p>If column expressions or LIMIT/OFFSET/DISTINCT are present,
the query &quot;SELECT count(1) FROM (SELECT ...)&quot; is issued,
so that the result matches the total number of rows
this query would return.  For mapped entities,
the primary key columns of each is written to the
columns clause of the nested SELECT statement.</p>
<p>For a Query which is only against mapped entities,
a simpler &quot;SELECT count(1) FROM table1, table2, ...
WHERE criterion&quot; is issued.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def delete(<i>self</i>, <i>synchronize_session='fetch'</i>)</b>
    <div class="docstring">
    <p>Perform a bulk delete query.</p>
<p>Deletes rows matched by this query from the database. The synchronize_session
parameter chooses the strategy for the removal of matched objects from the
session. Valid values are:</p>
<dl class="docutils">
<dt>False</dt>
<dd>don't synchronize the session. Use this when you don't need to use the
session after the delete or you can be sure that none of the matched objects
are in the session. The behavior of deleted objects still in the session is
undefined.</dd>
<dt>'fetch'</dt>
<dd>performs a select query before the delete to find objects that are matched
by the delete query and need to be removed from the session. Matched objects
are removed from the session. 'fetch' is the default strategy.</dd>
<dt>'evaluate'</dt>
<dd><p class="first">experimental feature. Tries to evaluate the querys criteria in Python
straight on the objects in the session. If evaluation of the criteria isn't
implemented, the 'fetch' strategy will be used as a fallback.</p>
<p class="last">The expression evaluator currently doesn't account for differing string
collations between the database and Python.</p>
</dd>
</dl>
<p>Returns the number of rows deleted, excluding any cascades.</p>
<p>Warning - this currently doesn't account for any foreign key/relation cascades.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def distinct(<i>self</i>)</b>
    <div class="docstring">
    <p>Apply a <tt class="docutils literal"><span class="pre">DISTINCT</span></tt> to the query and return the newly resulting
<tt class="docutils literal"><span class="pre">Query</span></tt>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def filter(<i>self</i>, <i>criterion</i>)</b>
    <div class="docstring">
    <p>apply the given filtering criterion to the query and return the newly resulting <tt class="docutils literal"><span class="pre">Query</span></tt></p>
<p>the criterion is any sql.ClauseElement applicable to the WHERE clause of a select.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def filter_by(<i>self</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    <p>apply the given filtering criterion to the query and return the newly resulting <tt class="docutils literal"><span class="pre">Query</span></tt>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def first(<i>self</i>)</b>
    <div class="docstring">
    <p>Return the first result of this <tt class="docutils literal"><span class="pre">Query</span></tt> or None if the result doesn't contain any row.</p>
<p>This results in an execution of the underlying query.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def from_self(<i>self</i>, <i>*entities</i>)</b>
    <div class="docstring">
    <p>return a Query that selects from this Query's SELECT statement.</p>
<p>*entities - optional list of entities which will replace
those being selected.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def from_statement(<i>self</i>, <i>statement</i>)</b>
    <div class="docstring">
    <p>Execute the given SELECT statement and return results.</p>
<p>This method bypasses all internal statement compilation, and the
statement is executed without modification.</p>
<p>The statement argument is either a string, a <tt class="docutils literal"><span class="pre">select()</span></tt> construct,
or a <tt class="docutils literal"><span class="pre">text()</span></tt> construct, and should return the set of columns
appropriate to the entity class represented by this <tt class="docutils literal"><span class="pre">Query</span></tt>.</p>
<p>Also see the <tt class="docutils literal"><span class="pre">instances()</span></tt> method.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def get(<i>self</i>, <i>ident</i>)</b>
    <div class="docstring">
    <p>Return an instance of the object based on the given identifier, or None if not found.</p>
<p>The <cite>ident</cite> argument is a scalar or tuple of primary key column values
in the order of the table def's primary key columns.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def group_by(<i>self</i>, <i>*criterion</i>)</b>
    <div class="docstring">
    <p>apply one or more GROUP BY criterion to the query and return the newly resulting <tt class="docutils literal"><span class="pre">Query</span></tt></p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def having(<i>self</i>, <i>criterion</i>)</b>
    <div class="docstring">
    <p>apply a HAVING criterion to the query and return the newly resulting <tt class="docutils literal"><span class="pre">Query</span></tt>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def instances(<i>self</i>, <i>cursor</i>, <i>_Query__context=None</i>)</b>
    <div class="docstring">
    <p>Given a ResultProxy cursor as returned by connection.execute(), return an ORM result as an iterator.</p>
<p>e.g.:</p>
<pre class="literal-block">
result = engine.execute(&quot;select * from users&quot;)
for u in session.query(User).instances(result):
    print u
</pre>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def iterate_instances(<i>self</i>, <i>cursor</i>, <i>_Query__context=None</i>)</b>
    <div class="docstring">
    <p>Given a ResultProxy cursor as returned by connection.execute(), return an ORM result as an iterator.</p>
<p>Deprecated.</p>
<p>e.g.:</p>
<pre class="literal-block">
result = engine.execute(&quot;select * from users&quot;)
for u in session.query(User).instances(result):
    print u
</pre>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def join(<i>self</i>, <i>*props</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    <p>Create a join against this <tt class="docutils literal"><span class="pre">Query</span></tt> object's criterion
and apply generatively, returning the newly resulting <tt class="docutils literal"><span class="pre">Query</span></tt>.</p>
<p>Each element in *props may be:</p>
<blockquote>
<ul class="simple">
<li>a string property name, i.e. &quot;rooms&quot;.  This will join along the
relation of the same name from this Query's &quot;primary&quot; mapper, if
one is present.</li>
<li>a class-mapped attribute, i.e. Houses.rooms.  This will create a
join from &quot;Houses&quot; table to that of the &quot;rooms&quot; relation.</li>
<li>a 2-tuple containing a target class or selectable, and an &quot;ON&quot;
clause.  The ON clause can be the property name/ attribute like
above, or a SQL expression.</li>
</ul>
</blockquote>
<p>e.g.:</p>
<pre class="literal-block">
# join along string attribute names
session.query(Company).join('employees')
session.query(Company).join('employees', 'tasks')

# join the Person entity to an alias of itself,
# along the &quot;friends&quot; relation
PAlias = aliased(Person)
session.query(Person).join((Palias, Person.friends))

# join from Houses to the &quot;rooms&quot; attribute on the
# &quot;Colonials&quot; subclass of Houses, then join to the
# &quot;closets&quot; relation on Room
session.query(Houses).join(Colonials.rooms, Room.closets)

# join from Company entities to the &quot;employees&quot; collection,
# using &quot;people JOIN engineers&quot; as the target.  Then join
# to the &quot;computers&quot; collection on the Engineer entity.
session.query(Company).join((people.join(engineers), 'employees'), Engineer.computers)

# join from Articles to Keywords, using the &quot;keywords&quot; attribute.
# assume this is a many-to-many relation.
session.query(Article).join(Article.keywords)

# same thing, but spelled out entirely explicitly
# including the association table.
session.query(Article).join(
    (article_keywords, Articles.id==article_keywords.c.article_id),
    (Keyword, Keyword.id==article_keywords.c.keyword_id)
    )
</pre>
<p>**kwargs include:</p>
<blockquote>
<p>aliased - when joining, create anonymous aliases of each table.  This is
used for self-referential joins or multiple joins to the same table.
Consider usage of the aliased(SomeClass) construct as a more explicit
approach to this.</p>
<p>from_joinpoint - when joins are specified using string property names,
locate the property from the mapper found in the most recent previous
join() call, instead of from the root entity.</p>
</blockquote>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def limit(<i>self</i>, <i>limit</i>)</b>
    <div class="docstring">
    <p>Apply a <tt class="docutils literal"><span class="pre">LIMIT</span></tt> to the query and return the newly resulting</p>
<p><tt class="docutils literal"><span class="pre">Query</span></tt>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def offset(<i>self</i>, <i>offset</i>)</b>
    <div class="docstring">
    <p>Apply an <tt class="docutils literal"><span class="pre">OFFSET</span></tt> to the query and return the newly resulting
<tt class="docutils literal"><span class="pre">Query</span></tt>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def one(<i>self</i>)</b>
    <div class="docstring">
    <p>Return exactly one result or raise an exception.</p>
<p>Raises <tt class="docutils literal"><span class="pre">sqlalchemy.orm.exc.NoResultFound</span></tt> if the query selects no rows.
Raises <tt class="docutils literal"><span class="pre">sqlalchemy.orm.exc.MultipleResultsFound</span></tt> if multiple rows are
selected.</p>
<p>This results in an execution of the underlying query.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def options(<i>self</i>, <i>*args</i>)</b>
    <div class="docstring">
    <p>Return a new Query object, applying the given list of
MapperOptions.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def order_by(<i>self</i>, <i>*criterion</i>)</b>
    <div class="docstring">
    <p>apply one or more ORDER BY criterion to the query and return the newly resulting <tt class="docutils literal"><span class="pre">Query</span></tt></p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def outerjoin(<i>self</i>, <i>*props</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    <p>Create a left outer join against this <tt class="docutils literal"><span class="pre">Query</span></tt> object's criterion
and apply generatively, retunring the newly resulting <tt class="docutils literal"><span class="pre">Query</span></tt>.</p>
<p>Usage is the same as the <tt class="docutils literal"><span class="pre">join()</span></tt> method.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def params(<i>self</i>, <i>*args</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    <p>add values for bind parameters which may have been specified in filter().</p>
<p>parameters may be specified using **kwargs, or optionally a single dictionary
as the first positional argument.  The reason for both is that **kwargs is
convenient, however some parameter dictionaries contain unicode keys in which case
**kwargs cannot be used.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def populate_existing(<i>self</i>)</b>
    <div class="docstring">
    <p>Return a Query that will refresh all instances loaded.</p>
<p>This includes all entities accessed from the database, including
secondary entities, eagerly-loaded collection items.</p>
<p>All changes present on entities which are already present in the
session will be reset and the entities will all be marked &quot;clean&quot;.</p>
<p>An alternative to populate_existing() is to expire the Session
fully using session.expire_all().</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def query_from_parent(<i>cls</i>, <i>instance</i>, <i>property</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    <p>Return a new Query with criterion corresponding to a parent instance.</p>
<p>Deprecated.  Use sqlalchemy.orm.with_parent in conjunction with filter().</p>
<p>Return a newly constructed Query object, with criterion corresponding
to a relationship to the given parent instance.</p>
<dl class="docutils">
<dt>instance</dt>
<dd><blockquote class="first">
a persistent or detached instance which is related to class
represented by this query.</blockquote>
<dl class="last docutils">
<dt>property</dt>
<dd>string name of the property which relates this query's class to the
instance.</dd>
<dt>**kwargs</dt>
<dd>all extra keyword arguments are propagated to the constructor of
Query.</dd>
</dl>
</dd>
</dl>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def reset_joinpoint(<i>self</i>)</b>
    <div class="docstring">
    <p>return a new Query reset the 'joinpoint' of this Query reset
back to the starting mapper.  Subsequent generative calls will
be constructed from the new joinpoint.</p>
<p>Note that each call to join() or outerjoin() also starts from
the root.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def scalar(<i>self</i>)</b>
    <div class="docstring">
    <p>Return the first element of the first result or None.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; session.query(Item).scalar()
&lt;Item&gt;
&gt;&gt;&gt; session.query(Item.id).scalar()
1
&gt;&gt;&gt; session.query(Item.id).filter(Item.id &lt; 0).scalar()
None
&gt;&gt;&gt; session.query(Item.id, Item.name).scalar()
1
&gt;&gt;&gt; session.query(func.count(Parent.id)).scalar()
20
</pre>
</blockquote>
<p>This results in an execution of the underlying query.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def select_from(<i>self</i>, <i>from_obj</i>)</b>
    <div class="docstring">
    <p>Set the <cite>from_obj</cite> parameter of the query and return the newly
resulting <tt class="docutils literal"><span class="pre">Query</span></tt>.  This replaces the table which this Query selects
from with the given table.</p>
<p><cite>from_obj</cite> is a single table or selectable.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def slice(<i>self</i>, <i>start</i>, <i>stop</i>)</b>
    <div class="docstring">
    <p>apply LIMIT/OFFSET to the <tt class="docutils literal"><span class="pre">Query</span></tt> based on a range and return the newly resulting <tt class="docutils literal"><span class="pre">Query</span></tt>.</p>

    </div>
    </div>

                    
         <div class="darkcell">
         <A name=""></a>
         <b>statement = property()</b>
         <div class="docstring">
         <p>The full SELECT statement represented by this Query.</p>

         </div> 
         </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def subquery(<i>self</i>)</b>
    <div class="docstring">
    <p>return the full SELECT statement represented by this Query, embedded within an Alias.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def update(<i>self</i>, <i>values</i>, <i>synchronize_session='expire'</i>)</b>
    <div class="docstring">
    <p>Perform a bulk update query.</p>
<p>Updates rows matched by this query in the database. The values parameter takes
a dictionary with object attributes as keys and literal values or sql expressions
as values. The synchronize_session parameter chooses the strategy to update the
attributes on objects in the session. Valid values are:</p>
<dl class="docutils">
<dt>False</dt>
<dd>don't synchronize the session. Use this when you don't need to use the
session after the update or you can be sure that none of the matched objects
are in the session.</dd>
<dt>'expire'</dt>
<dd>performs a select query before the update to find objects that are matched
by the update query. The updated attributes are expired on matched objects.</dd>
<dt>'evaluate'</dt>
<dd><p class="first">experimental feature. Tries to evaluate the querys criteria in Python
straight on the objects in the session. If evaluation of the criteria isn't
implemented, the 'expire' strategy will be used as a fallback.</p>
<p class="last">The expression evaluator currently doesn't account for differing string
collations between the database and Python.</p>
</dd>
</dl>
<p>Returns the number of rows matched by the update.</p>
<p>Warning - this currently doesn't account for any foreign key/relation cascades.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def value(<i>self</i>, <i>column</i>)</b>
    <div class="docstring">
    <p>Return a scalar result corresponding to the given column expression.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def values(<i>self</i>, <i>*columns</i>)</b>
    <div class="docstring">
    <p>Return an iterator yielding result tuples corresponding to the given list of columns</p>

    </div>
    </div>

                    
         <div class="darkcell">
         <A name=""></a>
         <b>whereclause = property()</b>
         <div class="docstring">
         <p>The WHERE criterion for this Query.</p>

         </div> 
         </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def with_labels(<i>self</i>)</b>
    <div class="docstring">
    <p>Apply column labels to the return value of Query.statement.</p>
<p>Indicates that this Query's <cite>statement</cite> accessor should return
a SELECT statement that applies labels to all columns in the
form &lt;tablename&gt;_&lt;columnname&gt;; this is commonly used to
disambiguate columns from multiple tables which have the same
name.</p>
<p>When the <cite>Query</cite> actually issues SQL to load rows, it always
uses column labeling.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def with_lockmode(<i>self</i>, <i>mode</i>)</b>
    <div class="docstring">
    <p>Return a new Query object with the specified locking mode.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def with_parent(<i>self</i>, <i>instance</i>, <i>property=None</i>)</b>
    <div class="docstring">
    <p>Add a join criterion corresponding to a relationship to the given
parent instance.</p>
<dl class="docutils">
<dt>instance</dt>
<dd>a persistent or detached instance which is related to class
represented by this query.</dd>
<dt>property</dt>
<dd>string name of the property which relates this query's class to the
instance.  if None, the method will attempt to find a suitable
property.</dd>
</dl>
<p>Currently, this method only works with immediate parent relationships,
but in the future may be enhanced to work across a chain of parent
mappers.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def with_polymorphic(<i>self</i>, <i>cls_or_mappers</i>, <i>selectable=None</i>)</b>
    <div class="docstring">
    <p>Load columns for descendant mappers of this Query's mapper.</p>
<p>Using this method will ensure that each descendant mapper's
tables are included in the FROM clause, and will allow filter()
criterion to be used against those tables.  The resulting
instances will also have those columns already loaded so that
no &quot;post fetch&quot; of those columns will be required.</p>
<p><tt class="docutils literal"><span class="pre">cls_or_mappers</span></tt> is a single class or mapper, or list of class/mappers,
which inherit from this Query's mapper.  Alternatively, it
may also be the string <tt class="docutils literal"><span class="pre">'*'</span></tt>, in which case all descending
mappers will be added to the FROM clause.</p>
<p><tt class="docutils literal"><span class="pre">selectable</span></tt> is a table or select() statement that will
be used in place of the generated FROM clause.  This argument
is required if any of the desired mappers use concrete table
inheritance, since SQLAlchemy currently cannot generate UNIONs
among tables automatically.  If used, the <tt class="docutils literal"><span class="pre">selectable</span></tt>
argument must represent the full set of tables and columns mapped
by every desired mapper.  Otherwise, the unaccounted mapped columns
will result in their table being appended directly to the FROM
clause which will usually lead to incorrect results.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def yield_per(<i>self</i>, <i>count</i>)</b>
    <div class="docstring">
    <p>Yield only <tt class="docutils literal"><span class="pre">count</span></tt> rows at a time.</p>
<p>WARNING: use this method with caution; if the same instance is present
in more than one batch of rows, end-user changes to attributes will be
overwritten.</p>
<p>In particular, it's usually impossible to use this setting with
eagerly loaded collections (i.e. any lazy=False) since those
collections will be cleared for a new load when encountered in a
subsequent result batch.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __getitem__(<i>self</i>, <i>item</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __iter__(<i>self</i>)</b>
    <div class="docstring">
    
    </div>
    </div>


    

            <a href="#top" class="totoc">back to section top</a>
    </div>



    

    </div>





    <div class="bottomnav">
        
    <div class="prevnext">
            Up: <a href="docstrings.html">API Documentation</a>

               |   
            Previous: <a href="sqlalchemy_orm_properties.html">module sqlalchemy.orm.properties</a>

               |   
            Next: <a href="sqlalchemy_orm_session.html">module sqlalchemy.orm.session</a>
    </div>

    </div>








</body>
</html>






